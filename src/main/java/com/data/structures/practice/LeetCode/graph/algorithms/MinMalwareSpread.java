package com.data.structures.practice.LeetCode.graph.algorithms;

import java.util.ArrayList;
import java.util.List;

public class MinMalwareSpread {
    public static void main(String[] args) {

       // int[][] graph = {{1,1,0},{1,1,0},{0,0,1}};
        //int[] initial = {0,1};
        //int[][] graph = {{1,0,0},{0,1,0},{0,0,1}};
        //int[] initial = {0,2};
        int[][] graph = {{1,1,0},{1,1,0},{0,0,1}};
        int[] initial = {0,1,2};

        System.out.println(minMalwareSpread(graph, initial));

    }
    static int[] desc, low, parent;
    static boolean[] au;
    static int times;
    static List<List<Integer>> al;
    public static int minMalwareSpread(int[][] graph, int[] initial) {
        int m=graph.length;
        int n = graph[0].length;
        times=0;
        desc= new int[m];
        low = new int[m];
        parent=new int[m];
        au=new boolean[m];
        al = new ArrayList<>();

        for(int i=0;i<m;i++){
            al.add(new ArrayList<>());
            desc[i] =-1;
            parent[i]=-1;
            for(int j=0;j<n;j++){
                if(i!= j && graph[i][j]==1){
                    al.get(i).add(j);
                }
            }
        }

        for(int u: initial){
            if(desc[u]==-1){
                dfs(u);
            }
        }

        for(int i=0;i<m;i++){
            if(au[i])return i;
        }
        return -1;
    }

    public static void dfs(int u){
        int children=0;
        desc[u]=low[u]=times++;
        for(int v: al.get(u)){
            if(desc[v]==-1){
                parent[v]=u;
                children++;
                dfs(v);

                low[u]= Math.min(low[v], low[u]);

                if(parent[u] ==-1 && children>0)au[u]=true;
                if(parent[u] !=-1 && low[v]>=desc[u])au[u]=true;

            }else if(v != parent[u]){
                low[u]= Math.min(low[v], desc[u]);
            }
        }
    }
}
